1.排序的分类
    1.1 按数据存储介质:  内部排序和外部排序
    1.2 按比较器的个数:  串行排序和并行排序
    1.3 按主要操作:      比较排序和基数排序
    1.4 按辅助空间:      原地排序和非原地排序
    1.5 按稳定性:        稳定排序和非稳定排序
    1.6 按自然性:        自然排序和非自然排序

2.内部排序方法的分类: （根据逐步扩大记录有序序列长度不同的原则）
    2.1 插入类 : 直接插入 、折半插入、希尔排序
    2.2 交换类 : 冒泡排序和快速排序
    2.3 选择类 : 简单选择排序、树形选择排序和堆排序
    2.4 归并类 : 归并排序方法
    2.5 分配类 : 基数排序
3.待排序记录的存储方式: 
    3.1 顺序表 :  记录之间的次序关系由其存储位置决定,实现排序需要移动记录
    3.2 链表   :  记录之间的次序关系由指针指示,实现排序不需要移动记录,只需要修改指针。称为链表排序
4.排序算法效率的评价指标
    4.1 执行时间 
    4.2 辅助空间
5.插入排序
    5.1 直接插入
        时间复杂度: O(n*n)  最好情况: O(n) 最坏情况: O(n*n) 平均情况O(n*n)
        空间复杂度: O(1) 只需要一个辅助空间
        算法特点:  
            5.1.1 稳定排序
            5.1.2 算法简便,且容易实现
            5.1.3 也适用于链式存储结构,只是在单链表上无需移动记录,只需修改相应的指针
            5.1.4 更适合于初始记录基本有序（正序）的情况,当初始记录无须,,较大时,此算法时间复杂度较高,不宜使用。
        提高查找速度: 
            减少元素的比较次数
            减少元素的查找次数
    5.2 折半插入排序
        时间复杂度: O(n*n)
        空间复杂度: O(1) 只需要一个辅助空间
        算法特点: 
            5.2.1 稳定排序
            5.2.2 因为要进行折半查找,所以只能用于顺序结构,不能用于链式结构
            5.2.3 适合初始记录无序,n比较大的情况
        相对于直接插入排序: 减少了比较次数,但没有减少移动次数  平均性能优于直接插入排序
    5.3 希尔排序
        空间复杂度: O(1)
        时间复杂度: 最好情况O(n) 最坏情况: O(n*n) 平均情况: O(n的1.3次方） 算法效率与增量序列的取值有关
        算法特点: 
            5.3.1 不稳定排序(记录跳跃式地移动)
            5.3.2 只能用于顺序结构,不能用于链式结构
            5.3.3 增量序列可以有各种取法,但应该使增量序列中的值除了1没有公因子,并且最后一个增量值必须等于1
            5.3.4 记录总的比较次数和移动次数都比直接插入排序要小,n越大,效果越明显。所以是适用于初始记录无须,n较大的情况。 
6. 交换排序
    6.1 冒泡排序
        时间复杂度: 最好情况O(n) 最坏情况: O(n*n) 平均情况:O(n*n)
        空间复杂度： O(1)
        算法特点:
            6.1.1 稳定排序
            6.1.2 可用于链式存储结构
            6.1.3 移动记录次数较多,算法平均时间性能比直接插入排序差。当初始记录无须,n比较大的情况,不宜使用。    
    6.2 快速排序
        时间复杂度: O(n*log以2为底n的对数)
        空间复杂度：平均情况 需要O(log以2为底n的对数)的栈空间 最坏情况O(n);由于程序中使用了递归,需要递归调用栈的指出，而栈的长度取决于递归调用的深度。（即使不用递归，也需要用用户栈）;
        算法特点
            6.2.1 记录非顺次的移动导致排序方法是不稳定的
            6.2.2 排序过程中需要定位表的下届和上街,所以适合用于顺序结构,很难用于链式结构
            6.2.3 当n较大时,在平均情况下快速排序是所有内部排序方法中速度较快的一种,所以适合初始记录无记录,n比较大的情况;