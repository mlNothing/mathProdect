1.排序的分类
    1.1 按数据存储介质:  内部排序和外部排序
    1.2 按比较器的个数:  串行排序和并行排序
    1.3 按主要操作:      比较排序和基数排序
    1.4 按辅助空间:      原地排序和非原地排序
    1.5 按稳定性:        稳定排序和非稳定排序
    1.6 按自然性:        自然排序和非自然排序

2.内部排序方法的分类: （根据逐步扩大记录有序序列长度不同的原则）
    2.1 插入类 : 直接插入 、折半插入、希尔排序
    2.2 交换类 : 冒泡排序和快速排序
    2.3 选择类 : 简单选择排序、树形选择排序和堆排序
    2.4 归并类 : 归并排序方法
    2.5 分配类 : 基数排序
3.待排序记录的存储方式: 
    3.1 顺序表 :  记录之间的次序关系由其存储位置决定,实现排序需要移动记录
    3.2 链表   :  记录之间的次序关系由指针指示,实现排序不需要移动记录,只需要修改指针。称为链表排序
4.排序算法效率的评价指标
    4.1 执行时间 
    4.2 辅助空间
5.插入排序
    5.1 直接插入
        时间复杂度: O(n*n)  最好情况: O(n) 最坏情况: O(n*n) 平均情况O(n*n)
        空间复杂度: O(1) 只需要一个辅助空间
        算法特点:  
            5.1.1 稳定排序
            5.1.2 算法简便,且容易实现
            5.1.3 也适用于链式存储结构,只是在单链表上无需移动记录,只需修改相应的指针
            5.1.4 更适合于初始记录基本有序（正序）的情况,当初始记录无须,,较大时,此算法时间复杂度较高,不宜使用。
        提高查找速度: 
            减少元素的比较次数
            减少元素的查找次数
    5.2 折半插入排序
        时间复杂度: O(n*n)
        空间复杂度: O(1) 只需要一个辅助空间
        算法特点: 
            5.2.1 稳定排序
            5.2.2 因为要进行折半查找,所以只能用于顺序结构,不能用于链式结构
            5.2.3 适合初始记录无序,n比较大的情况
        相对于直接插入排序: 减少了比较次数,但没有减少移动次数  平均性能优于直接插入排序
    5.3 希尔排序
        空间复杂度: O(1)
        时间复杂度: 最好情况O(n) 最坏情况: O(n*n) 平均情况: O(n的1.3次方） 算法效率与增量序列的取值有关
        算法特点: 
            5.3.1 不稳定排序(记录跳跃式地移动)
            5.3.2 只能用于顺序结构,不能用于链式结构
            5.3.3 增量序列可以有各种取法,但应该使增量序列中的值除了1没有公因子,并且最后一个增量值必须等于1
            5.3.4 记录总的比较次数和移动次数都比直接插入排序要小,n越大,效果越明显。所以是适用于初始记录无须,n较大的情况。 
6. 交换排序
    6.1 冒泡排序
        时间复杂度: 最好情况O(n) 最坏情况: O(n*n) 平均情况:O(n*n)
        空间复杂度： O(1)
        算法特点:
            6.1.1 稳定排序
            6.1.2 可用于链式存储结构
            6.1.3 移动记录次数较多,算法平均时间性能比直接插入排序差。当初始记录无须,n比较大的情况,不宜使用。    
    6.2 快速排序
        时间复杂度: O(n*log以2为底n的对数)
        空间复杂度：平均情况 需要O(log以2为底n的对数)的栈空间 最坏情况O(n);由于程序中使用了递归,需要递归调用栈的指出，而栈的长度取决于递归调用的深度。（即使不用递归，也需要用用户栈）;
        算法特点
            6.2.1 记录非顺次的移动导致排序方法是不稳定的
            6.2.2 排序过程中需要定位表的下届和上街,所以适合用于顺序结构,很难用于链式结构
            6.2.3 当n较大时,在平均情况下快速排序是所有内部排序方法中速度较快的一种,所以适合初始记录无记录,n比较大的情况;
7.选择排序
    7.1 直接选择排序
        空间复杂度: O(1)
        时间复杂度: O(n*n)
        算法特点：
            7.1.1 不稳定排序
            7.1.2 可用于链式存储结构 
    7.2 堆排序
        堆的定义：  若n个元素的序列{a1,a2...an}满足ai<a2i,ai<a2i+1成为(小根堆)反之则成为大根堆
        从堆的定义可以看出堆实质是满足如下性质的完全二叉树的：二叉树中任一非叶子结点均小于或大于它的孩子结点。
        堆排序：
            若在输出堆顶的最小值（最大值）后,使得n-1个元素的序列重又建成一个堆,则得到n个元素的次小值(次大值)...如此反复,便能的到一个有序序列,这个过程成为堆排序
        时间复杂度: O(nlogn)
        空间复杂度: O(1) 仅需提供一个记录大小供交换用的辅助存储空间
        算法特点：
            7.2.1 不稳定排序
            7.2.2 只能用于顺序结构 不能用于链式结构
            7.2.3 初始建堆所需的比较次数较多,因此记录数较少时不宜采用。堆排序在最坏情况下时间复杂度为 O(nlogn),相对于快速排序O(n*n)是一个优点，当记录时较多时较为高效。 
8.归并排序
        归并排序就是将两个或两个以上的有序表合并成一个有序表的过程---2路归并
        思想：
            假设初始序列含有n个记录,则可以堪称n个有序的子序列,每个子序列的长度为1,然后两两归并,得到n/2个长度为2或1的
            有序子序列,再两两归并...如此反复,直至得到一个长度为n的有序序列为止.
        算法分析：
            时间复杂度: O(nlogn)
            空间复杂度: O(n) 需要和排序记录个数相等的辅助存储空间
        算法特点：
            7.3.1 是稳定排序
            7.3.2 可用于链式存储结构 且不需要附加存储空间 但递归实现时仍需要开辟相应的递归空间栈
9.分类排序
    9.1基数排序:通过若干趟的分配与收集
        算法分析：
            时间复杂度: O(d(n+rd))
            空间复杂度: O(n+rd)
        算法特点：
            9.1.1 稳定排序
            9.1.2 可用于链式存储结构 也可以用于顺序结构
            9.1.3 时间复杂度可以突破基于关键字的比较一类方法的下界O(nlogn),达到O(n)
            9.1.4 基数排序使用条件有严格要求,需要各级关键字的主次关系和各级关键字的取值范围